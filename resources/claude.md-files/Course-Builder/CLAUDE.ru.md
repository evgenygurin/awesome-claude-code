# Руководство по разработке Course Builder

## Обзор проекта

Course Builder - это многопользовательская CMS (система управления контентом) реального времени, специально разработанная для создания и развертывания продуктов для обучения разработчиков. Этот монорепозиторий содержит несколько приложений и общих пакетов, которые работают вместе, чтобы предоставить комплексную платформу для создания, управления и доставки образовательного контента.

### Основные функции
- Управление контентом для курсов, модулей и уроков
- Конвейер обработки видео с транскрипцией
- Создание и улучшение контента с помощью ИИ
- Совместная работа в реальном времени для создателей контента
- Аутентификация и авторизация
- Обработка платежей и управление подписками
- Отслеживание прогресса для студентов

### Ключевые технологии
- **Фреймворк**: Next.js (App Router)
- **Язык**: TypeScript
- **Монорепозиторий**: Turborepo с рабочими пространствами PNPM
- **База данных**: Drizzle ORM с MySQL/PlanetScale
- **Аутентификация**: NextAuth.js
- **Стилизация**: Tailwind CSS
- **API**: tRPC для типобезопасных вызовов API
- **Реальное время**: PartyKit/websockets для совместной работы
- **Обработка событий**: Inngest для рабочих процессов и фоновых задач
- **Медиа**: Mux для обработки видео, Deepgram для транскрипции
- **ИИ**: OpenAI/GPT для помощи с контентом
- **Платежи**: Интеграция со Stripe

## Структура репозитория

### Приложения (`/apps`)
- `ai-hero`: Основное приложение, ориентированное на обучение с помощью ИИ
- `astro-party`: Реализация на основе Astro
- `course-builder-web`: Основное веб-приложение Course Builder
- `egghead`: Интеграция с платформой egghead.io
- `epic-react`: Специальная реализация для курсов по React
- `go-local-first`: Реализация с возможностями локального приоритета

### Пакеты (`/packages`)
- **Основная функциональность**:
  - `core`: Основная библиотека, независимая от фреймворка
  - `ui`: Общие компоненты UI на основе Radix/shadcn
  - `adapter-drizzle`: Адаптер базы данных для Drizzle ORM
  - `next`: Привязки, специфичные для Next.js
  - `commerce-next`: Компоненты и функциональность для коммерции

- **Пакеты утилит**:
  - `utils-ai`: Утилиты, связанные с ИИ
  - `utils-auth`: Утилиты аутентификации и авторизации
  - `utils-aws`: Утилиты сервисов AWS
  - `utils-browser`: Утилиты для браузера (куки и т.д.)
  - `utils-core`: Основные утилиты, такие как `guid`
  - `utils-email`: Утилиты, связанные с электронной почтой
  - `utils-file`: Утилиты для работы с файлами
  - `utils-media`: Утилиты обработки медиа
  - `utils-resource`: Утилиты фильтрации и обработки ресурсов
  - `utils-search`: Утилиты функциональности поиска
  - `utils-seo`: Утилиты SEO
  - `utils-string`: Утилиты манипуляции строками
  - `utils-ui`: Утилиты UI, такие как `cn`

### Другие директории
- `cli`: Инструменты командной строки для начальной загрузки проекта
- `docs`: Документация, включая руководство по общим утилитам
- `instructions`: Подробные инструкции для задач разработки
- `plop-templates`: Шаблоны для генерации кода

## Справочник команд

### Команды сборки
- `pnpm build:all` - Сборка всех пакетов и приложений
- `pnpm build` - Сборка всех пакетов (не приложений)
- `pnpm build --filter="ai-hero"` - Сборка конкретного приложения
- `pnpm dev:all` - Запуск среды разработки для всех пакетов/приложений
- `pnpm dev` - Запуск среды разработки только для пакетов

### Тестирование
- `pnpm test` - Запуск всех тестов
- `pnpm test --filter="@coursebuilder/utils-file"` - Тестирование конкретного пакета
- `pnpm test:watch` - Запуск тестов в режиме наблюдения
- `cd packages/package-name && pnpm test` - Запуск тестов для конкретного пакета
- `cd packages/package-name && pnpm test src/path/to/test.test.ts` - Запуск одного тестового файла
- `cd packages/package-name && pnpm test:watch src/path/to/test.test.ts` - Наблюдение за одним тестовым файлом

### Линтинг и форматирование
- `pnpm lint` - Запуск линтинга на всех пакетах/приложениях
- `pnpm format:check` - Проверка форматирования без изменения файлов
- `pnpm format` - Форматирование всех файлов с помощью Prettier
- `pnpm typecheck` - Запуск проверки типов TypeScript
- `pnpm manypkg fix` - Исправление несоответствий версий зависимостей и сортировка файлов package.json

Используйте `--filter="APP_NAME"` для запуска команд для конкретного приложения

## Генерация кода и создание каркаса

### Создание новых пакетов утилит
Используйте пользовательский шаблон Plop для создания новых пакетов утилит:

```bash
# Создание нового пакета утилит с использованием шаблона
pnpm plop package-utils <domain> <utilityName> <functionName> "<utilityDescription>"

# Пример:
pnpm plop package-utils browser cookies getCookies "Утилита для работы с куками браузера"

# С именованными параметрами:
pnpm plop package-utils -- --domain browser --utilityName cookies --functionName getCookies --utilityDescription "Утилита для работы с куками браузера"
```

Это создаст правильно структурированный пакет с:
- Корректным package.json с конфигурацией экспортов
- Конфигурацией TypeScript
- Базовой реализацией с правильными комментариями TSDoc
- Каркасом для тестирования

### Работа с пакетами утилит

#### Добавление зависимостей
При обновлении файлов package.json для добавления зависимостей:
1. Используйте замену строк с помощью инструмента Edit для добавления зависимостей
2. Поддерживайте алфавитный порядок зависимостей
3. Не заменяйте целые разделы, просто добавляйте новую строку

Пример правильного редактирования package.json:
```
"@coursebuilder/utils-media": "1.0.0",
"@coursebuilder/utils-seo": "1.0.0",

// Заменить на:
"@coursebuilder/utils-media": "1.0.0",
"@coursebuilder/utils-resource": "1.0.0", // Новая строка добавлена здесь
"@coursebuilder/utils-seo": "1.0.0",
```

#### Совместимость с фреймворками
При создании пакетов утилит, взаимодействующих с библиотеками, специфичными для фреймворка:
1. Держите зависимости, специфичные для фреймворка (React, Next.js и т.д.), как одноранговые зависимости
2. Для утилит, использующих сторонние библиотеки (такие как Typesense, OpenAI), предоставляйте адаптеры, а не прямые реализации
3. Будьте осторожны с библиотеками, которые могут конфликтовать с внутренними компонентами фреймворка
4. Тестируйте сборки в нескольких приложениях для обеспечения совместимости

## Стиль кода
- **Форматирование**: Одинарные кавычки, без точек с запятой, табуляция (ширина: 2), ограничение строки в 80 символов
- **Импорты**: Организованы в определенном порядке (React → Next → сторонние → внутренние)
- **Структура файлов**: Монорепозиторий с приложениями в /apps и пакетами в /packages
- **Менеджер пакетов**: PNPM (v8.15.5+)
- **Фреймворк тестирования**: Vitest

### Conventional Commits
Мы используем conventional commits с областями, специфичными для пакета/приложения:
- Формат: `<тип>(<область>): <описание>`
- Типы: `feat`, `fix`, `refactor`, `style`, `docs`, `test`, `chore`
- Области:
  - Коды приложений: `aih` (ai-hero), `egh` (egghead), `eweb` (epic-web)
  - Пакеты: `utils-email`, `core`, `ui`, `mdx-mermaid` и т.д.

Примеры:
- `fix(egh): преобразование SanityReference в SanityArrayElementReference`
- `style(mdx-mermaid): улучшение блок-схем`
- `refactor(utils): реализация пакета утилит SEO с шаблоном реэкспорта`
- `feat(utils-email): создание пакета утилит электронной почты с sendAnEmail`

## Общие шаблоны

### Управление зависимостями
При добавлении зависимостей в пакеты в монорепозитории убедитесь, что:
1. Все пакеты используют согласованные версии зависимостей
2. Зависимости в файлах package.json отсортированы в алфавитном порядке

Если вы столкнулись с ошибками линтинга, связанными с версиями зависимостей или сортировкой:
```bash
# Исправление несоответствий версий зависимостей и сортировка файлов package.json
pnpm manypkg fix
```

### Шаблон реэкспорта для обратной совместимости
При создании общих пакетов утилит используйте шаблон реэкспорта для поддержания обратной совместимости:

```typescript
// В /apps/app-name/src/utils/some-utility.ts
// Реэкспорт из общего пакета
export { someUtility } from '@coursebuilder/utils-domain/some-utility'
```

Это сохраняет существующие пути импорта по всей кодовой базе, перемещая реализацию в общий пакет.

#### Важно: Избегайте Object.defineProperty для реэкспортов
НЕ используйте `Object.defineProperty(exports, ...)` для реэкспортов, так как это может вызвать конфликты с внутренними компонентами фреймворка, особенно с Next.js и tRPC:

```typescript
// НЕ ДЕЛАЙТЕ ТАК - может вызвать ошибки "Cannot redefine property" при сборке
Object.defineProperty(exports, 'someFunction', {
  value: function() { /* реализация */ }
})

// ВМЕСТО ЭТОГО ДЕЛАЙТЕ ТАК - стандартный шаблон экспорта
export function someFunction() { /* реализация */ }
```

Эти конфликты обычно проявляются как ошибки "Cannot redefine property" во время сборки и их трудно отлаживать. Они возникают, потому что процесс сборки может пытаться определить одно и то же свойство несколько раз через различные механизмы объединения.

### Комментарии TSDoc для утилит
Всегда включайте комплексные комментарии TSDoc для функций утилит:

```typescript
/**
 * Краткое описание того, что делает функция
 * 
 * Дополнительные детали, если необходимо
 * 
 * @param paramName - Описание параметра
 * @returns Описание возвращаемого значения
 * 
 * @example
 * ```ts
 * // Пример кода использования
 * const result = myFunction('input')
 * ```
 */
```

### Шаблон структуры директории приложения
Большинство приложений следуют этой общей структуре директорий:
- `src/app` - Страницы и макеты Next.js App Router
- `src/components` - Компоненты React
- `src/lib` - Бизнес-логика, специфичная для домена
- `src/utils` - Функции утилит
- `src/db` - Схема базы данных и запросы
- `src/server` - Серверные функции и маршруты API
- `src/hooks` - Хуки React
- `src/trpc` - Маршрутизатор tRPC и процедуры

### Схема базы данных
Большинство приложений используют Drizzle ORM со схемой в `src/db/schema.ts`, которая обычно включает:
- Пользователей и аутентификацию
- Ресурсы контента (курсы, модули, уроки)
- Отслеживание прогресса
- Покупки и подписки

### Шаблон аутентификации
Аутентификация обычно следует этому шаблону:
- NextAuth.js для провайдеров аутентификации
- Определения возможностей CASL для авторизации
- Пользовательское промежуточное ПО для защиты маршрутов

